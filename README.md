<h1></h1>
<h1 align="Center">𝑨𝒓𝒓𝒂𝒚𝒔 𝑨𝒏𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚</h1>

<br>

<br>

<h1 align="Center">𝟏.𝑴𝒆𝒎𝒐𝒓𝒚 𝑹𝒆𝒑𝒓𝒆𝒔𝒆𝒏𝒕𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝑨𝒓𝒓𝒂𝒚𝒔 </h1>
<ul>

<h3>𝑨𝒓𝒓𝒂𝒚 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆 𝒂 𝒎𝒆𝒎𝒐𝒓𝒚 𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒆𝒂𝒄𝒉 𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏
′𝒔 𝒔𝒊𝒛𝒆 
𝒊𝒔 𝒕𝒉𝒆 𝒔𝒊𝒛𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒅𝒂𝒕𝒂 𝒕𝒚𝒑𝒆. 𝑺𝒖𝒑𝒑𝒐𝒔𝒆 𝒊𝒕 𝒊𝒔 𝒊𝒏𝒕𝒆𝒈𝒆𝒓 𝒘𝒉𝒊𝒄𝒉 𝒊𝒔 𝒐𝒇 𝟒 𝒃𝒚𝒕𝒆𝒔 𝒂𝒏𝒅 𝒂𝒓𝒓𝒂𝒚𝒔 𝒃𝒚𝒕𝒆 𝒊𝒔 
𝟓 𝒕𝒉𝒆𝒏 𝒊𝒕 𝒉𝒐𝒍𝒅𝒔 𝟓 𝒂𝒅𝒋𝒂𝒄𝒆𝒏𝒕 𝒄𝒐𝒏𝒕𝒊𝒈𝒖𝒐𝒖𝒔 𝒎𝒆𝒎𝒐𝒓𝒚 𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏 
𝒘𝒊𝒕𝒉 𝒊𝒏𝒅𝒆𝒙𝒆𝒔.</h3>

<h1 align="Center">𝟏. 𝑨.𝑺𝒊𝒏𝒈𝒍𝒆 𝑫𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝑨𝒓𝒓𝒂𝒚𝒔 </h2>

<ul>

<img src="https://user-images.githubusercontent.com/38869235/234256245-a5c52bce-1725-4f24-b29d-9f6a8e7d2eda.png" width=850  height=300>

<h3>𝒂𝒓𝒓[𝟎] = 𝟏 , 𝒂𝒓𝒓[𝟏] = 𝟐,𝒂𝒓𝒓[𝟐] = 𝟑
𝒂𝒓𝒓[𝟑] = 𝟒 
𝒂𝒓𝒓[𝟒] = 𝟓. 𝑯𝒆𝒓𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 = 𝟏, 𝟐, 𝟑, 𝟒, 𝟓 𝒂𝒏𝒅 𝒊𝒏𝒅𝒆𝒙 = 𝟎, 𝟏, 𝟐, 𝟑, 𝟒. 
𝑨𝒏𝒅 𝒆𝒂𝒄𝒉 𝒊𝒏𝒅𝒆𝒙 𝒊𝒔 𝒔𝒊𝒛𝒆𝒅 𝟒 𝒃𝒚𝒕𝒆𝒔 𝒆𝒂𝒄𝒉 = 𝟐𝟎 𝒃𝒚𝒕𝒆𝒔.</h3>



</ul>

<h1></h1>
<h1 align="Center">𝟏. 𝑪. 𝑻𝒉𝒓𝒆𝒆 − 𝑫𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝑨𝒓𝒓𝒂𝒚𝒔   </h2>

<ul>



<img src="https://user-images.githubusercontent.com/38869235/234271018-95adf9eb-80f8-4af8-8822-5fdbda13d4b0.png">

<h3>𝒘𝒉𝒆𝒓𝒆 , 𝒓𝒐𝒘 = 𝟑 𝒂𝒏𝒅 𝒄𝒐𝒍𝒖𝒎𝒏 = 𝟒. 𝑯𝒆𝒏𝒄𝒆 𝑻𝒐𝒕𝒂𝒍 𝑴𝒆𝒎𝒐𝒓𝒚 𝒕𝒂𝒌𝒆𝒏 𝒃𝒚 𝒕𝒉𝒆 𝑨𝒓𝒓𝒂𝒚 
= 𝟒 × 𝟑 × 𝟒𝒃𝒚𝒕𝒆𝒔 = 𝟒𝟖 𝒃𝒚𝒕𝒆𝒔.</h3>

<h3>𝑵𝒐𝒕𝒆: 𝑨𝒔 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 𝒂𝒅𝒋𝒂𝒄𝒆𝒏𝒕 𝒄𝒐𝒏𝒕𝒊𝒈𝒖𝒐𝒖𝒔 
𝒎𝒆𝒎𝒐𝒓𝒚 𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏 𝒊𝒕 𝒍𝒐𝒐𝒌𝒔 𝒍𝒊𝒌𝒆:</h3>

![Screenshot (361)](https://user-images.githubusercontent.com/38869235/234276456-ab7efe5a-f3fd-4c46-b48e-285062789dd9.png)

</ul>

<h1></h1>

<h1 align="Center">𝟐. 𝑰𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝑨𝒓𝒓𝒂𝒚 𝒂𝒏𝒅 𝒊𝒕𝒔
𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 </h1>

<ul>

<h3>𝑻𝒉𝒆𝒓𝒆 𝒂𝒓𝒆 𝒕𝒘𝒐 𝒕𝒚𝒑𝒆𝒔 𝒐𝒇 𝒂𝒓𝒓𝒂𝒚𝒔 𝒐𝒏 𝒃𝒂𝒔𝒊𝒔 𝒐𝒇 𝒎𝒆𝒎𝒐𝒓𝒚 𝑨𝒍𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏:</h3>

<ul>

<h3><li>𝑺𝒕𝒂𝒕𝒊𝒄 𝒂𝒓𝒓𝒂𝒚:  </li></h3>

<ul>

<h3>→ 𝑻𝒂𝒌𝒆𝒔 𝒂 𝒇𝒊𝒙𝒆𝒅 𝒔𝒊𝒛𝒆 𝒐𝒇 𝒂𝒓𝒓𝒂𝒚 𝒂𝒕 𝒄𝒐𝒎𝒑𝒊𝒍𝒆𝒅 𝒕𝒊𝒎𝒆.</h3>

<h3>→ 𝑨𝒔 𝒑𝒆𝒓 𝒑𝒓𝒐𝒑𝒆𝒓𝒕𝒚 𝒐𝒇 𝒂𝒓𝒓𝒂𝒚 , 𝒕𝒉𝒆𝒚 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒔
𝒎𝒆𝒎𝒐𝒓𝒚 𝒄𝒐𝒏𝒕𝒊𝒈𝒖𝒐𝒖𝒔𝒍𝒚 𝒐𝒓 𝒂𝒅𝒋𝒂𝒄𝒆𝒏𝒕𝒍𝒚 𝒘𝒊𝒕𝒉
𝒊𝒏𝒅𝒆𝒙 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒑𝒑𝒐𝒔𝒊𝒕𝒆 𝒕𝒐 𝒆𝒂𝒄𝒉 𝒎𝒆𝒎𝒐𝒓𝒚
𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏.</h3>


<h3>→ 𝑻𝒉𝒆𝒚 𝒈𝒆𝒕 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅 𝒃𝒚 𝒕𝒉𝒆𝒎𝒔𝒆𝒍𝒗𝒆𝒔
𝒂𝒇𝒕𝒆𝒓 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒈𝒆𝒕𝒔 𝒄𝒐𝒎𝒑𝒊𝒍𝒆𝒅.</h3>

![Screenshot (362)](https://user-images.githubusercontent.com/38869235/234332663-b8af3b34-25f2-48c7-b3b4-aaf8f582d739.png)


</ul>



<h3><li>𝑫𝒚𝒏𝒂𝒎𝒊𝒄 𝑨𝒓𝒓𝒂𝒚:</li></h3>

<ul>


<h3>→𝑾𝒉𝒆𝒏 𝒊𝒕 𝒊𝒔 𝒄𝒓𝒆𝒂𝒕𝒆𝒅 𝒎𝒂𝒚 𝒃𝒆 𝒉𝒂𝒗𝒆 𝒂 𝒑𝒓𝒊𝒎𝒂𝒓𝒚 𝒔𝒊𝒛𝒆 𝒃𝒖𝒕 𝒄𝒐𝒏𝒔𝒖𝒎𝒆 𝒂 𝒍𝒂𝒓𝒈𝒆 𝒔𝒊𝒛𝒆 𝒊𝒏 𝒉𝒆𝒂𝒑 𝒎𝒆𝒎𝒐𝒓𝒚. </h3>

<h3>→𝑻𝒉𝒆 𝒔𝒊𝒛𝒆 𝒊𝒔 𝒐𝒏𝒍𝒚 𝒃𝒆 𝒅𝒆𝒕𝒆𝒓𝒎𝒊𝒏𝒆𝒅 𝒂𝒕 𝒕𝒉𝒆 𝒓𝒖𝒏 𝒕𝒊𝒎𝒆.</h3> 


<h3>→𝑰𝒏 𝑪/𝑪++ ,𝒊𝒕 𝒅𝒊𝒅 𝒏𝒐𝒕 𝒈𝒆𝒕 𝒅𝒆𝒔𝒕𝒓𝒐𝒚𝒆𝒅 𝒃𝒖𝒕 𝒘𝒆 𝒅𝒆𝒔𝒕𝒓𝒐𝒚 𝒐𝒓 𝒇𝒓𝒆𝒆 𝒕𝒉𝒆 𝒎𝒆𝒎𝒐𝒓𝒚 𝒎𝒂𝒏𝒖𝒂𝒍𝒍𝒚 .𝑵𝒐𝒕𝒆 , "𝒇𝒓𝒆𝒆" 𝒌𝒆𝒚𝒘𝒐𝒓𝒅 𝒊𝒔 𝒐𝒏𝒍𝒚 𝒂𝒔𝒔𝒐𝒄𝒊𝒂𝒕𝒆𝒅 𝒘𝒊𝒕𝒉 "𝒎𝒂𝒍𝒍𝒐𝒄" .</h3> 

![Screenshot (363)](https://user-images.githubusercontent.com/38869235/234332850-711002b0-2bc1-40d2-bc36-f9567847d88f.png)

<h3>→𝑹𝒆𝒑𝒍𝒂𝒄𝒊𝒏𝒈 𝒎𝒂𝒍𝒍𝒐𝒄 , 𝒕𝒉𝒆 𝒏𝒆𝒘 𝒌𝒆𝒚𝒘𝒐𝒓𝒅 
𝒊𝒏𝒕𝒓𝒐𝒅𝒖𝒄𝒆𝒅 𝒊𝒏 𝑪++ 𝒓𝒆𝒅𝒖𝒄𝒊𝒏𝒈 𝒎𝒂𝒍𝒍𝒐𝒄 𝒔𝒚𝒏𝒕𝒂𝒙 𝒂𝒏𝒅 
𝒘𝒆 "𝒅𝒆𝒍𝒆𝒕𝒆 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚" 𝒘𝒊𝒕𝒉 "𝒅𝒆𝒍𝒆𝒕𝒆" 𝒌𝒆𝒚𝒘𝒐𝒓𝒅. 
𝑯𝒆𝒏𝒄𝒆 𝒕𝒉𝒆 𝒊𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒂𝒕𝒊𝒐𝒏 𝒘𝒊𝒕𝒉 𝒏𝒆𝒘 𝒌𝒆𝒚𝒘𝒐𝒓𝒅 𝒊𝒔 
𝒅𝒚𝒏𝒂𝒎𝒊𝒄 𝒎𝒆𝒎𝒐𝒓𝒚 𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒊𝒐𝒏.</h3> 

![Screenshot (381)](https://user-images.githubusercontent.com/38869235/234637224-0ddfe09d-5670-475d-910d-b95526c6cf3a.png)


<h3>→𝑰𝒏 𝑱𝒂𝒗𝒂 , 𝒘𝒆 𝒓𝒆𝒎𝒐𝒗𝒆 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒖𝒔𝒆 𝒐𝒇 𝒅𝒐𝒕 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒂𝒏𝒅 𝒏𝒆𝒘 𝒌𝒆𝒚𝒘𝒐𝒓𝒅 𝒄𝒐𝒏𝒕𝒊𝒏𝒖𝒆𝒅 𝒅𝒖𝒆 𝒕𝒐 𝒔𝒆𝒄𝒖𝒓𝒊𝒕𝒚 𝒐𝒇 𝒂𝒅𝒅𝒓𝒆𝒔𝒔. 𝑻𝒉𝒓𝒐𝒖𝒈𝒉 𝒑𝒐𝒊𝒏𝒕𝒆𝒓 𝒂𝒅𝒅𝒓𝒆𝒔𝒔 𝒊𝒔 𝒆𝒙𝒑𝒐𝒔𝒆𝒅 , 𝒉𝒆𝒏𝒄𝒆 𝒓𝒆𝒎𝒐𝒗𝒆𝒅 𝒇𝒓𝒐𝒎 𝒋𝒂𝒗𝒂. 𝑬𝒗𝒆𝒏 𝒂𝒇𝒕𝒆𝒓 𝒘𝒆 𝒄𝒓𝒆𝒂𝒕𝒆 𝒂 𝒅𝒚𝒏𝒂𝒎𝒊𝒄 𝒂𝒓𝒓𝒂𝒚 𝒊𝒏 𝒋𝒂𝒗𝒂 𝒘𝒊𝒕𝒉 𝒏𝒆𝒘 𝒌𝒆𝒚𝒘𝒐𝒓𝒅 𝒂𝒏𝒅 𝒊𝒕 𝒔𝒕𝒂𝒚𝒔 𝒊𝒏 𝒕𝒉𝒆 𝒎𝒆𝒎𝒐𝒓𝒚 , 𝒕𝒉𝒆 𝒓𝒆𝒇𝒆𝒓𝒆𝒏𝒄𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒖𝒏𝒖𝒔𝒆𝒅 𝒂𝒓𝒓𝒂𝒚 𝒃𝒆𝒄𝒐𝒎𝒆𝒔 𝒖𝒔𝒆𝒍𝒆𝒔𝒔 𝒂𝒏𝒅 𝒈𝒂𝒓𝒃𝒂𝒈𝒆 𝒄𝒐𝒍𝒍𝒆𝒄𝒕𝒐𝒓 𝒐𝒇 𝒋𝒂𝒗𝒂 𝒄𝒐𝒎𝒑𝒊𝒍𝒆𝒓 𝒕𝒂𝒌𝒆𝒔 𝒄𝒂𝒓𝒆 𝒐𝒇 𝒊𝒕 𝒊.𝒆. 𝒇𝒊𝒓𝒔𝒕 𝒊𝒕
𝒅𝒆𝒂𝒍𝒍𝒐𝒄𝒂𝒕𝒆𝒔 𝒂𝒏𝒅 𝒇𝒓𝒆𝒆 𝒖𝒑 𝒕𝒉𝒆 𝒎𝒆𝒎𝒐𝒓𝒚.</h3> 

![Screenshot (380)](https://user-images.githubusercontent.com/38869235/234637322-cb8b44c9-e0e5-4316-ae8a-3591bcb469e6.png)


</ul>

<h2> </h2>
<h2 align="Center"> 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝑰𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝑨𝒓𝒓𝒂𝒚𝒔 </h2>

<ul>
<h3>→𝑻𝒉𝒐𝒖𝒈𝒉 𝒉𝒂𝒗𝒊𝒏𝒈 𝒅𝒊𝒔𝒕𝒊𝒏𝒄𝒕 𝒔𝒊𝒛𝒆 , 𝑨𝒓𝒓𝒂𝒚 𝒘𝒉𝒊𝒍𝒆 𝒊𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒂𝒕𝒊𝒐𝒏 , 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 1 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒕𝒊𝒎𝒆 𝒕𝒐 𝒈𝒆𝒕 𝒊𝒏𝒊𝒕𝒊𝒂𝒍𝒊𝒛𝒆𝒅. 𝑯𝒆𝒏𝒄𝒆 𝒖𝒑𝒑𝒆𝒓 𝒃𝒐𝒖𝒏𝒅 𝒊𝒔: <ins>𝑩𝒊𝒈-𝑶 ⟹𝑶(1) </ins>.</h3> 

</ul>
</ul>

</ul>



</ul>

<h1></h1>

<h1 align="Center"> 𝟑. 𝑻𝒓𝒂𝒗𝒆𝒓𝒔𝒂𝒍 𝒐𝒇 𝑨𝒓𝒓𝒂𝒚𝒔</h1>

<ul>

<h3>→𝑻𝒓𝒂𝒗𝒆𝒓𝒔𝒂𝒍 𝒊𝒔 𝒂 𝒘𝒐𝒓𝒅 𝒕𝒉𝒂𝒕 𝒄𝒐𝒎𝒆𝒔 𝒇𝒓𝒐𝒎 𝒈𝒓𝒂𝒑𝒉 𝒓𝒆𝒑𝒓𝒆𝒔𝒆𝒏𝒕𝒂𝒕𝒊𝒐𝒏. 
𝑰𝒕 𝒎𝒆𝒂𝒏𝒔 𝒎𝒐𝒗𝒊𝒏𝒈 𝒇𝒓𝒐𝒎 𝒐𝒏𝒆 𝒆𝒏𝒅 𝒐𝒇 𝒂 𝒑𝒂𝒕𝒉 𝒕𝒐 𝒂𝒏𝒐𝒕𝒉𝒆𝒓.</h3>

![Screenshot (366)](https://user-images.githubusercontent.com/38869235/234337398-f6b833b7-1f71-40c3-97bd-c7a24eb27022.png)

![Screenshot (367)](https://user-images.githubusercontent.com/38869235/234337933-879a2448-aa46-4502-99d2-623a42f874b8.png)



<h2> </h2>
<h2 align="Center">  𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝑻𝒓𝒂𝒗𝒆𝒓𝒔𝒂𝒍 𝒐𝒇 𝑨𝒓𝒓𝒂𝒚𝒔 </h2>


<ul>

<h3>→ 𝑾𝒆 𝒔𝒆𝒆 𝒕𝒉𝒂𝒕 𝑨𝒓𝒓𝒂𝒚 𝒕𝒓𝒂𝒗𝒆𝒓𝒔𝒂𝒍 𝒑𝒓𝒐𝒄𝒆𝒆𝒅𝒔 
𝒇𝒓𝒐𝒎: </h3>

<h3> 𝒂[𝟎] − −𝑶(𝟏) </h3>
<h3> 𝒂[𝟏] − −𝑶(𝟏) </h3> 
<h3> 𝒂[𝟐] − −𝑶(𝟏) </h3> 
<h3> ….. </h3>
<h3> 𝒂[𝒏] − −𝑶(𝟏) </h3> 

<h3> 𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆 𝒊𝒇 𝟏 + 𝟏 + 𝟏 + ⋯ . +𝒏 𝒕𝒊𝒎𝒆𝒔 
𝒈𝒊𝒗𝒆𝒔: 𝑶(𝒏) 𝒕𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚. </h3> 

</ul>

</ul>


<h1></h1>

<h1 align="Center"> 𝟒.𝑶𝒗𝒆𝒓𝒓𝒊𝒅𝒊𝒏𝒈 𝒊𝒕𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕</h1>

<ul>

![Screenshot (370)](https://user-images.githubusercontent.com/38869235/234346773-666ef345-de55-4bb3-b20a-3f45b07278df.png)


<h3> 𝑯𝒆𝒏𝒄𝒆 𝒉𝒆𝒓𝒆 𝒘𝒆 𝒐𝒗𝒆𝒓𝒓𝒊𝒅𝒆 𝒕𝒉𝒆 0𝒕𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕:
𝒂𝒏𝒅 𝒂𝒃𝒔𝒐𝒍𝒖𝒕𝒆𝒍𝒚 𝒕𝒉𝒆 𝒓𝒖𝒏𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒊𝒔:
𝑶(𝟏). </h3> 

</ul>

<h1> </h1>

<h1 align="Center"> 𝟓. 𝑰𝒏𝒔𝒆𝒓𝒕 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝑨𝒓𝒓𝒂𝒚 </h1>

<ul>

<h3>𝑰𝒇 𝒘𝒆 𝒊𝒏𝒔𝒆𝒓𝒕 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒕𝒉𝒓𝒐𝒖𝒈𝒉 𝒖𝒔𝒆𝒓 𝒊𝒏𝒑𝒖𝒕, 
𝒂𝒕 𝒆𝒂𝒄𝒉 𝒊𝒏𝒅𝒆𝒙 𝒐𝒇 𝒂𝒏 𝒂𝒓𝒓𝒂𝒚, 𝒊𝒕 𝒍𝒐𝒐𝒌𝒔 𝒍𝒊𝒌𝒆:</h3> 

![Screenshot (371)](https://user-images.githubusercontent.com/38869235/234348928-35980844-eeb4-4a0e-9290-9629f8d203a7.png)


<h3>𝑯𝒆𝒏𝒄𝒆 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒏𝒈 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒂𝒕 𝒆𝒂𝒄𝒉 𝒊𝒏𝒅𝒆𝒙 𝒏𝒆𝒆𝒅𝒔 𝒕𝒓𝒂𝒗𝒆𝒓𝒔𝒂𝒍:
𝒂[𝟎]−→ 𝒂[𝟏]−→ 𝒂[𝟐]−→ ⋯ −→ 𝒂[𝒏]</h3> 


<h2> </h2>
<h2 align="Center">  𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝑰𝒏𝒔𝒆𝒓𝒕 𝑬𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏 𝑨𝒓𝒓𝒂𝒚 </h2>

<ul>

<h3>𝑻𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒊𝒔 𝒄𝒍𝒆𝒂𝒓𝒍𝒚 ∶ 𝑶(𝒏).
𝑾𝒉𝒆𝒓𝒆 𝒏 𝒊𝒔 𝒕𝒉𝒆 𝒔𝒊𝒛𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 𝒏.𝑻𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒏𝒈 𝒂 𝒔𝒊𝒏𝒈𝒍𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏𝒕𝒐 𝒂𝒏
𝒂𝒓𝒓𝒂𝒚 𝒂𝒕 𝒂 𝒔𝒑𝒆𝒄𝒊𝒇𝒊𝒄 𝒊𝒏𝒅𝒆𝒙 𝒊𝒔 𝑶 (𝟏)𝒊𝒇 𝒕𝒉𝒆 𝒊𝒏𝒅𝒆𝒙 𝒊𝒔 𝒌𝒏𝒐𝒘𝒏.
𝑯𝒐𝒘𝒆𝒗𝒆𝒓, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒏𝒈 `𝒏` 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏𝒕𝒐
𝒂𝒏 𝒂𝒓𝒓𝒂𝒚 𝒔𝒆𝒒𝒖𝒆𝒏𝒕𝒊𝒂𝒍𝒍𝒚 𝒊𝒔 𝑶(𝒏), 𝒔𝒊𝒏𝒄𝒆 𝒘𝒆 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒑𝒆𝒓𝒇𝒐𝒓𝒎 𝒕𝒉𝒆
𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 ′𝒏′ 𝒕𝒊𝒎𝒆𝒔.</h3> 

</ul>

</ul>

<h1> </h1>

<h1 align="Center">𝟔.  𝑰𝒏𝒔𝒆𝒓𝒕 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒂𝒕 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 𝑰𝒏 𝒂𝒏 
𝑨𝒓𝒓𝒂𝒚</h1>

<ul>

<h3><ins>𝑨𝒑𝒑𝒓𝒐𝒂𝒄𝒉:</ins></h3> 
<h3><li>𝟏𝒔𝒕 𝑾𝒆 𝒊𝒏𝒄𝒓𝒆𝒎𝒆𝒏𝒕 𝒕𝒉𝒆 𝒔𝒊𝒛𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚: </li></h3>

<ul>

<h3><li>𝒔𝒊𝒛𝒆 = 𝒔𝒊𝒛𝒆 + 𝟏; </li></h3>

</ul>

<h3><li>𝟐𝒏𝒅 𝒘𝒆 𝒔𝒉𝒊𝒇𝒕 𝒕𝒉𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒇𝒓𝒐𝒎 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 𝒕𝒐 
𝒍𝒂𝒔𝒕 𝒊𝒏𝒅𝒆𝒙: </li></h3>

<ul>

<h3><li>𝒔𝒖𝒑𝒑𝒐𝒔𝒆 𝒔𝒊𝒛𝒆 = 𝟓 𝒂𝒏𝒅 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒊𝒏𝒅𝒆𝒙𝒆𝒔: 
𝒂[𝟎], 𝒂[𝟏], 𝒂[𝟐], 𝒂[𝟑] 𝒂𝒏𝒅 𝒂[𝟒],𝒂𝒔 𝒔𝒊𝒛𝒆 𝒊𝒏𝒄𝒓𝒆𝒂𝒔𝒆𝒅 , 𝒏𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒓𝒓𝒂𝒚 𝒊𝒏𝒅𝒆𝒙𝒆𝒔: 
𝒂[𝟎], 𝒂[𝟏], 𝒂[𝟐], 𝒂[𝟑], 𝒂[𝟒] , 𝒂[𝟓] 𝒂𝒏𝒅 𝒔𝒊𝒛𝒆 = 𝟔. </li></h3>

</ul>
 
<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒑𝒖𝒕 𝒕𝒉𝒆 𝒂𝒕 𝒊𝒏𝒅𝒆𝒙 𝟏. 𝑯𝒆𝒏𝒄𝒆 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒔𝒘𝒂𝒑 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔:</li></h3>

<ul >
<h3><li>𝒂[𝟓] = 𝒂[𝟒] [𝒗𝒂𝒍𝒖𝒆𝒔 𝒈𝒆𝒕 𝒔𝒘𝒂𝒑𝒑𝒆𝒅] </li></h3>
<h3><li>𝒂[𝟒] = 𝒂[𝟑][𝒗𝒂𝒍𝒖𝒆𝒔 𝒈𝒆𝒕 𝒔𝒘𝒂𝒑𝒑𝒆𝒅]</li></h3> 
<h3><li>𝒂[𝟑] = 𝒂[𝟐][𝒗𝒂𝒍𝒖𝒆𝒔 𝒈𝒆𝒕 𝒔𝒘𝒂𝒑𝒑𝒆𝒅]</li></h3>  
<h3><li>𝒂[𝟐] = 𝒂[𝟏][𝒗𝒂𝒍𝒖𝒆𝒔 𝒈𝒆𝒕 𝒔𝒘𝒂𝒑𝒑𝒆𝒅] </li></h3>  

</ul>

<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒋𝒖𝒔𝒕 𝒘𝒊𝒍𝒍 𝒅𝒐 𝒊𝒔 𝒐𝒗𝒆𝒓𝒓𝒊𝒅𝒊𝒏𝒈 𝒕𝒉𝒆 𝒊𝒕𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕: </li></h3>
<ul>

<h3><li>𝒂[𝟏] = 𝒆𝒍𝒆𝒎 (𝑼𝒔𝒆𝒓 𝑰𝒏𝒑𝒖𝒕)</li></h3>

</ul>

<h3><ins>𝑷𝒓𝒐𝒈𝒓𝒂𝒎:</ins></h3> 

<ul>

![Screenshot (372)](https://user-images.githubusercontent.com/38869235/234362667-41ec9e62-15e7-4ecb-829c-9c1d402844dc.png)


</ul>

<h2> </h2>
<h2 align="Center">  𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝑰𝒏𝒔𝒆𝒓𝒕 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒂𝒕 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 𝑰𝒏 𝒂𝒏 
𝑨𝒓𝒓𝒂𝒚 </h2>

<ul>

<h3><li>𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆 𝒘𝒆 𝒔𝒆𝒆 𝒘𝒉𝒐𝒍𝒆 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 
𝒐𝒗𝒆𝒓𝒓𝒊𝒅𝒊𝒏𝒈 𝒐𝒇 𝒊𝒕𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒕𝒂𝒌𝒆𝒔: 
𝑶(𝟏)[𝑰𝒏𝒄𝒓𝒆𝒎𝒆𝒏𝒕] + 𝑶(𝒏)[𝑺𝒉𝒊𝒇𝒕] 
+𝑶(𝟏)[𝑶𝒗𝒆𝒓𝒓𝒊𝒅𝒆] = 𝑶(𝒏).</li></h3>

</ul>

<h1></h1>

<h1 align="Center">𝟕.𝑫𝒆𝒍𝒆𝒕𝒆 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒂𝒕 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 𝑰𝒏 𝒂𝒏 𝑨𝒓𝒓𝒂𝒚 </h1>

<ul>

<h3><ins>𝑨𝒑𝒑𝒓𝒐𝒂𝒄𝒉:</ins></h3> 

<h3><li>𝑺𝒖𝒑𝒑𝒐𝒔𝒆 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒔𝒊𝒛𝒆 = 𝟓 𝒂𝒏𝒅 
𝑨𝒏𝒅 𝒊𝒏𝒅𝒊𝒄𝒆𝒔: 𝒂[𝟎], 𝒂[𝟏], 𝒂[𝟐], 𝒂[𝟑] 𝒂𝒏𝒅 𝒂[𝟒]. </li></h3>

<h3><li>𝑨𝒏𝒅 𝒘𝒆 𝒘𝒂𝒏𝒕 𝒕𝒐 𝒅𝒆𝒍𝒆𝒕𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒂𝒕 𝒊𝒏𝒅𝒆𝒙: 𝟐 
𝑾𝒉𝒊𝒄𝒉 𝒎𝒆𝒂𝒏𝒔 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒕𝒐 𝒅𝒆𝒍𝒆𝒕𝒆 𝒊𝒏𝒅𝒆𝒙 ∶ 𝟐 𝒕𝒐𝒐.</li></h3> 
 
<h3><li>𝑻𝒉𝒆𝒏 𝒘𝒆 𝒈𝒐 𝒕𝒉𝒓𝒐𝒖𝒈𝒉 𝒂 𝒑𝒓𝒐𝒄𝒆𝒔𝒔 𝒐𝒇 𝑺𝒘𝒂𝒑𝒑𝒊𝒏𝒈: </li></h3>

<ul>

<h3><li>𝒂[𝟐 − 𝟏 = 𝟏] = 𝒂[𝟐 + 𝟏 = 𝟑]−→ 𝒆𝒍𝒆𝒎: 𝟑 .</li></h3>
<h3><li>𝒂[𝟑 − 𝟏 = 𝟐] = 𝒂[𝟑 + 𝟏 = 𝟒]−→ 𝒆𝒍𝒆𝒎: 𝟒. </li></h3>
<h3><li>𝒂[𝟒 − 𝟏 = 𝟑] = 𝒂[𝟒 + 𝟏 = 𝟓]−→ 𝒆𝒍𝒆𝒎: 𝟓 .</li></h3>

</ul>

<h3><li>𝑨𝒏𝒅 𝒂[𝟎]𝒘𝒊𝒍𝒍 𝒃𝒆 𝒓𝒆𝒎𝒂𝒊𝒏 𝒖𝒏𝒕𝒐𝒖𝒄𝒉𝒆𝒅. </li></h3>

<h3><li>𝑻𝒉𝒆𝒏 𝒘𝒆 𝒅𝒆𝒄𝒓𝒆𝒎𝒆𝒏𝒕 𝒕𝒉𝒆 𝒔𝒊𝒛𝒆: </li></h3>

<ul>

<h3><li>𝒔𝒊𝒛𝒆 = 𝒔𝒊𝒛𝒆 − 𝟏 , 𝒏𝒐𝒘 𝒔𝒊𝒛𝒆 𝒊𝒔 𝟒, 𝒕𝒓𝒂𝒗𝒆𝒓𝒔𝒂𝒍 𝒘𝒊𝒍𝒍 
𝒕𝒂𝒌𝒆 𝒑𝒍𝒂𝒄𝒆 𝒇𝒓𝒐𝒎 𝒂[𝟎] = 𝟏, 𝒂[𝟏] = 𝟑, 𝒂[𝟐] = 𝟒, 
𝒂𝒏𝒅 𝒂[𝟑] = 𝟓 . </li></h3>

</ul>


<h3><ins>𝑷𝒓𝒐𝒈𝒓𝒂𝒎:</ins></h3> 

<ul>

![Screenshot (373)](https://user-images.githubusercontent.com/38869235/234366984-eca29eb3-2d3f-4915-82fa-99261badca6e.png)

</ul>

</ul>

<h2></h2>
<h2 align="Center">  𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝑫𝒆𝒍𝒆𝒕𝒆 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒂𝒕 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 𝑰𝒏 𝒂𝒏 𝑨𝒓𝒓𝒂𝒚 </h2>

<ul>

<h3><li>𝑨𝒔,𝒍𝒐𝒐𝒑 𝒈𝒐𝒆𝒔 𝒇𝒓𝒐𝒎 𝒑𝒐𝒔𝒊𝒕𝒊𝒐𝒏 − 𝟏 𝒕𝒐 𝒔𝒊𝒛𝒆 − 𝟏 𝒊. 𝒆. 
𝟏 𝒕𝒐 𝒏 𝒕𝒊𝒎𝒆𝒔 = 𝑶(𝒏)𝒂𝒏𝒅 𝒔𝒊𝒛𝒆 𝒅𝒆𝒄𝒓𝒆𝒂𝒔𝒆𝒅 𝒊𝒔: 𝒔𝒊𝒛𝒆 − 𝟏 
= 𝑶(𝟏) , 𝒉𝒆𝒏𝒄𝒆 𝒕𝒐𝒕𝒂𝒍: 𝑶(𝒏) + 𝑶(𝟏) = 𝑶(𝒏).</li></h3>

</ul>



</ul>

<h1></h1>
<h1 align="Center">𝟖.𝑻𝒘𝒐 − 𝑫𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝑨𝒓𝒓𝒂𝒚 – 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚</h1>


<ul>

<h3><li>𝑻𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒆𝒏𝒕𝒆𝒓𝒊𝒏𝒈 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏𝒕𝒐 𝒂 𝒕𝒘𝒐-𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚 𝒅𝒆𝒑𝒆𝒏𝒅𝒔 𝒐𝒏 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒓𝒐𝒘𝒔 𝒂𝒏𝒅 𝒄𝒐𝒍𝒖𝒎𝒏𝒔 𝒊𝒏 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚, 𝒂𝒔 𝒘𝒆𝒍𝒍 𝒂𝒔 𝒕𝒉𝒆 𝒎𝒆𝒕𝒉𝒐𝒅 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 𝒕𝒉𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔.</li></h3>

<h3><li>𝑰𝒇 𝒘𝒆 𝒂𝒓𝒆 𝒆𝒏𝒕𝒆𝒓𝒊𝒏𝒈 𝒆𝒂𝒄𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒎𝒂𝒏𝒖𝒂𝒍𝒍𝒚, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒘𝒐𝒖𝒍𝒅 𝒃𝒆 𝑶(𝑵𝑴), 𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒓𝒐𝒘𝒔 𝒂𝒏𝒅 𝑴 𝒊𝒔 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒄𝒐𝒍𝒖𝒎𝒏𝒔. 𝑻𝒉𝒊𝒔 𝒊𝒔 𝒃𝒆𝒄𝒂𝒖𝒔𝒆 𝒘𝒆 𝒘𝒐𝒖𝒍𝒅 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒊𝒕𝒆𝒓𝒂𝒕𝒆 𝒕𝒉𝒓𝒐𝒖𝒈𝒉 𝒆𝒂𝒄𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 𝒊𝒕𝒔 𝒗𝒂𝒍𝒖𝒆, 𝒓𝒆𝒔𝒖𝒍𝒕𝒊𝒏𝒈 𝒊𝒏 𝑵𝑴 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔.</li></h3>

<h3><li>𝑰𝒇 𝒘𝒆 𝒂𝒓𝒆 𝒓𝒆𝒂𝒅𝒊𝒏𝒈 𝒊𝒏 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒇𝒓𝒐𝒎 𝒂 𝒇𝒊𝒍𝒆 𝒐𝒓 𝒔𝒐𝒎𝒆 𝒐𝒕𝒉𝒆𝒓 𝒅𝒂𝒕𝒂 𝒔𝒐𝒖𝒓𝒄𝒆, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒘𝒐𝒖𝒍𝒅 𝒅𝒆𝒑𝒆𝒏𝒅 𝒐𝒏 𝒕𝒉𝒆 𝒂𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒓𝒆𝒂𝒅 𝒊𝒏 𝒕𝒉𝒆 𝒅𝒂𝒕𝒂. 𝑰𝒏 𝒕𝒉𝒆 𝒃𝒆𝒔𝒕 𝒄𝒂𝒔𝒆, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒘𝒐𝒖𝒍𝒅 𝒃𝒆 𝑶(𝑵*𝑴), 𝒃𝒖𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆, 𝒊𝒕 𝒄𝒐𝒖𝒍𝒅 𝒃𝒆 𝒎𝒖𝒄𝒉 𝒉𝒊𝒈𝒉𝒆𝒓 𝒊𝒇 𝒕𝒉𝒆 𝒅𝒂𝒕𝒂 𝒔𝒐𝒖𝒓𝒄𝒆 𝒊𝒔 𝒗𝒆𝒓𝒚 𝒍𝒂𝒓𝒈𝒆 𝒐𝒓 𝒓𝒆𝒒𝒖𝒊𝒓𝒆𝒔 𝒄𝒐𝒎𝒑𝒍𝒆𝒙 𝒑𝒂𝒓𝒔𝒊𝒏𝒈.</li></h3>

<h3><li>𝑶𝒗𝒆𝒓𝒂𝒍𝒍, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒆𝒏𝒕𝒆𝒓𝒊𝒏𝒈 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏𝒕𝒐 𝒂 𝒕𝒘𝒐-𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚 𝒊𝒔 𝒑𝒓𝒊𝒎𝒂𝒓𝒊𝒍𝒚 𝒅𝒆𝒕𝒆𝒓𝒎𝒊𝒏𝒆𝒅 𝒃𝒚 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒕𝒉𝒂𝒕 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒃𝒆 𝒆𝒏𝒕𝒆𝒓𝒆𝒅, 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒎𝒆𝒕𝒉𝒐𝒅 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 𝒕𝒉𝒆𝒎.</li></h3>

</ul>

<h1></h1>
<h1 align="Center">. 𝟗.𝑻𝒉𝒓𝒆𝒆 − 𝑫𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝑨𝒓𝒓𝒂𝒚 – 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚</h1>

<ul>

<h3><li>𝑻𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒏𝒈 𝒂 𝒔𝒊𝒏𝒈𝒍𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏𝒕𝒐 𝒂𝒏 𝒂𝒓𝒓𝒂𝒚 𝒂𝒕 
𝒂 𝒔𝒑𝒆𝒄𝒊𝒇𝒊𝒄 𝒊𝒏𝒅𝒆𝒙 𝒊𝒔 𝑶 (1) 𝒊𝒇 𝒕𝒉𝒆 𝒊𝒏𝒅𝒆𝒙 𝒊𝒔 𝒌𝒏𝒐𝒘𝒏. 𝑯𝒐𝒘𝒆𝒗𝒆𝒓, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 
𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒏𝒈 '𝒏' 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏𝒕𝒐 𝒂𝒏 𝒂𝒓𝒓𝒂𝒚 𝒔𝒆𝒒𝒖𝒆𝒏𝒕𝒊𝒂𝒍𝒍𝒚 𝒊𝒔 
𝑶(𝒏), 𝒔𝒊𝒏𝒄𝒆 𝒘𝒆 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒑𝒆𝒓𝒇𝒐𝒓𝒎 𝒕𝒉𝒆 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 '𝒏' 𝒕𝒊𝒎𝒆𝒔.</li></h3>

<h3><li>𝑰𝒏 𝒕𝒉𝒆 𝒄𝒐𝒅𝒆 𝒔𝒏𝒊𝒑𝒑𝒆𝒕 𝒘𝒆 𝒑𝒓𝒐𝒗𝒊𝒅𝒆𝒅, 𝒘𝒆 𝒂𝒓𝒆 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒏𝒈 '𝒏' 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 
𝒊𝒏𝒕𝒐 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 𝒔𝒆𝒒𝒖𝒆𝒏𝒕𝒊𝒂𝒍𝒍𝒚 𝒃𝒚 𝒖𝒔𝒊𝒏𝒈 𝒂 𝒍𝒐𝒐𝒑, 𝒘𝒉𝒊𝒄𝒉 𝒎𝒆𝒂𝒏𝒔 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 
𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒕𝒉𝒆 𝒐𝒗𝒆𝒓𝒂𝒍𝒍 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒊𝒔 𝑶(𝒏).</li></h3>

<h3><li>𝑻𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒆𝒏𝒕𝒆𝒓𝒊𝒏𝒈 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏𝒕𝒐 𝒂 𝒕𝒉𝒓𝒆𝒆𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚 𝒂𝒍𝒔𝒐 𝒅𝒆𝒑𝒆𝒏𝒅𝒔 𝒐𝒏 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒓𝒐𝒘𝒔, 𝒄𝒐𝒍𝒖𝒎𝒏𝒔, 
𝒂𝒏𝒅 𝒅𝒆𝒑𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚, 𝒂𝒔 𝒘𝒆𝒍𝒍 𝒂𝒔 𝒕𝒉𝒆 𝒎𝒆𝒕𝒉𝒐𝒅 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 𝒕𝒉𝒆 
𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔.</li></h3>

<h3><li>𝑰𝒇 𝒘𝒆 𝒂𝒓𝒆 𝒆𝒏𝒕𝒆𝒓𝒊𝒏𝒈 𝒆𝒂𝒄𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒎𝒂𝒏𝒖𝒂𝒍𝒍𝒚, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 
𝒘𝒐𝒖𝒍𝒅 𝒃𝒆 𝑶(𝑷𝑵𝑴), 𝒘𝒉𝒆𝒓𝒆 𝑵 𝒊𝒔 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒓𝒐𝒘𝒔, 𝑴 𝒊𝒔 𝒕𝒉𝒆 
𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒄𝒐𝒍𝒖𝒎𝒏𝒔, 𝒂𝒏𝒅 𝑷 𝒊𝒔 𝒕𝒉𝒆 𝒅𝒆𝒑𝒕𝒉 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 (𝑵𝒐. 𝒐𝒇 𝑷𝒂𝒈𝒆𝒔).</li></h3> 

<h3><li>𝑻𝒉𝒊𝒔 𝒊𝒔 𝒃𝒆𝒄𝒂𝒖𝒔𝒆 𝒘𝒆 𝒘𝒐𝒖𝒍𝒅 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒊𝒕𝒆𝒓𝒂𝒕𝒆 𝒕𝒉𝒓𝒐𝒖𝒈𝒉 𝒆𝒂𝒄𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 
𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 𝒊𝒕𝒔 𝒗𝒂𝒍𝒖𝒆, 𝒓𝒆𝒔𝒖𝒍𝒕𝒊𝒏𝒈 𝒊𝒏 𝑵𝑴𝑷 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔.</li></h3> 

<h3><li>𝑰𝒇 𝒘𝒆 𝒂𝒓𝒆 𝒓𝒆𝒂𝒅𝒊𝒏𝒈 𝒊𝒏 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒇𝒓𝒐𝒎 𝒂 𝒇𝒊𝒍𝒆 𝒐𝒓 𝒔𝒐𝒎𝒆 𝒐𝒕𝒉𝒆𝒓 𝒅𝒂𝒕𝒂 
𝒔𝒐𝒖𝒓𝒄𝒆, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒘𝒐𝒖𝒍𝒅 𝒅𝒆𝒑𝒆𝒏𝒅 𝒐𝒏 𝒕𝒉𝒆 𝒂𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎 𝒖𝒔𝒆𝒅 
𝒕𝒐 𝒓𝒆𝒂𝒅 𝒊𝒏 𝒕𝒉𝒆 𝒅𝒂𝒕𝒂. 𝑰𝒏 𝒕𝒉𝒆 𝒃𝒆𝒔𝒕 𝒄𝒂𝒔𝒆, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒘𝒐𝒖𝒍𝒅 𝒃𝒆 
𝑶(𝑷𝑵𝑴), 𝒃𝒖𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆, 𝒊𝒕 𝒄𝒐𝒖𝒍𝒅 𝒃𝒆 𝒎𝒖𝒄𝒉 𝒉𝒊𝒈𝒉𝒆𝒓 𝒊𝒇 𝒕𝒉𝒆 𝒅𝒂𝒕𝒂 
𝒔𝒐𝒖𝒓𝒄𝒆 𝒊𝒔 𝒗𝒆𝒓𝒚 𝒍𝒂𝒓𝒈𝒆 𝒐𝒓 𝒓𝒆𝒒𝒖𝒊𝒓𝒆𝒔 𝒄𝒐𝒎𝒑𝒍𝒆𝒙 𝒑𝒂𝒓𝒔𝒊𝒏𝒈.</li></h3> 

<h3><li>𝑶𝒗𝒆𝒓𝒂𝒍𝒍, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒆𝒏𝒕𝒆𝒓𝒊𝒏𝒈 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏𝒕𝒐 𝒂 𝒕𝒉𝒓𝒆𝒆𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚 𝒊𝒔 𝒑𝒓𝒊𝒎𝒂𝒓𝒊𝒍𝒚 𝒅𝒆𝒕𝒆𝒓𝒎𝒊𝒏𝒆𝒅 𝒃𝒚 𝒕𝒉𝒆 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 
𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒕𝒉𝒂𝒕 𝒏𝒆𝒆𝒅 𝒕𝒐 𝒃𝒆 𝒆𝒏𝒕𝒆𝒓𝒆𝒅, 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒎𝒆𝒕𝒉𝒐𝒅 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 
𝒕𝒉𝒆𝒎. </li></h3> 

<h3><li>𝑯𝒐𝒘𝒆𝒗𝒆𝒓, 𝒔𝒊𝒏𝒄𝒆 𝒂 𝒕𝒉𝒓𝒆𝒆-𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚 𝒉𝒂𝒔 𝒎𝒐𝒓𝒆 
𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒕𝒉𝒂𝒏 𝒂 𝒕𝒘𝒐-𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚, 𝒕𝒉𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 
𝒘𝒐𝒖𝒍𝒅 𝒈𝒆𝒏𝒆𝒓𝒂𝒍𝒍𝒚 𝒃𝒆 𝒉𝒊𝒈𝒉𝒆𝒓 𝒇𝒐𝒓 𝒂 𝒕𝒉𝒓𝒆𝒆-𝒅𝒊𝒎𝒆𝒏𝒔𝒊𝒐𝒏𝒂𝒍 𝒂𝒓𝒓𝒂𝒚.</li></h3> 

</ul>

<h1></h1>
<h1 align="Center">𝟏𝟎.𝑹𝒆𝒂𝒍 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒂𝒏𝒅 𝑨𝒔𝒔𝒖𝒎𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚
𝒐𝒇 𝑨𝒓𝒓𝒂𝒚</h1>

<ul>

![Screenshot (377)](https://user-images.githubusercontent.com/38869235/234374597-b8fdc7a4-ed9f-4ba3-b4bc-ae57ff04de25.png)



</ul>







